<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>WASM Micro Runtime with Rust | Anoop's page</title><meta name=keywords content><meta name=description content="Traditionally, microcontrollers are known to be able to run only C code. Firmware developers will usually have an Eclipse-based IDE as well as a custom compiler toolchain to compile the code against the target. This has been changing a lot. For example, MicroPython has become popular recently. RaspberryPi Pico, ExpressIf&rsquo;s ESP32 are some microcontrollers that have fairly good support for MicroPython. See antirez&rsquo;s talk32 project, which attempts to improve the MicroPython tooling and developer workflow for ESP32."><meta name=author content="Anoop Elias"><link rel=canonical href=https://anoopelias.github.io/posts/wasm-micro-runtime-with-rust/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://anoopelias.github.io/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://anoopelias.github.io/assets/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://anoopelias.github.io/assets/favicon-32x32.png><link rel=apple-touch-icon href=https://anoopelias.github.io/apple-touch-icon.png><link rel=mask-icon href=https://anoopelias.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="WASM Micro Runtime with Rust"><meta property="og:description" content="Traditionally, microcontrollers are known to be able to run only C code. Firmware developers will usually have an Eclipse-based IDE as well as a custom compiler toolchain to compile the code against the target. This has been changing a lot. For example, MicroPython has become popular recently. RaspberryPi Pico, ExpressIf&rsquo;s ESP32 are some microcontrollers that have fairly good support for MicroPython. See antirez&rsquo;s talk32 project, which attempts to improve the MicroPython tooling and developer workflow for ESP32."><meta property="og:type" content="article"><meta property="og:url" content="https://anoopelias.github.io/posts/wasm-micro-runtime-with-rust/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="WASM Micro Runtime with Rust"><meta name=twitter:description content="Traditionally, microcontrollers are known to be able to run only C code. Firmware developers will usually have an Eclipse-based IDE as well as a custom compiler toolchain to compile the code against the target. This has been changing a lot. For example, MicroPython has become popular recently. RaspberryPi Pico, ExpressIf&rsquo;s ESP32 are some microcontrollers that have fairly good support for MicroPython. See antirez&rsquo;s talk32 project, which attempts to improve the MicroPython tooling and developer workflow for ESP32."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://anoopelias.github.io/posts/"},{"@type":"ListItem","position":3,"name":"WASM Micro Runtime with Rust","item":"https://anoopelias.github.io/posts/wasm-micro-runtime-with-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"WASM Micro Runtime with Rust","name":"WASM Micro Runtime with Rust","description":"Traditionally, microcontrollers are known to be able to run only C code. Firmware developers will usually have an Eclipse-based IDE as well as a custom compiler toolchain to compile the code against the target. This has been changing a lot. For example, MicroPython has become popular recently. RaspberryPi Pico, ExpressIf\u0026rsquo;s ESP32 are some microcontrollers that have fairly good support for MicroPython. See antirez\u0026rsquo;s talk32 project, which attempts to improve the MicroPython tooling and developer workflow for ESP32.","keywords":[],"articleBody":"Traditionally, microcontrollers are known to be able to run only C code. Firmware developers will usually have an Eclipse-based IDE as well as a custom compiler toolchain to compile the code against the target. This has been changing a lot. For example, MicroPython has become popular recently. RaspberryPi Pico, ExpressIf‚Äôs ESP32 are some microcontrollers that have fairly good support for MicroPython. See antirez‚Äôs talk32 project, which attempts to improve the MicroPython tooling and developer workflow for ESP32.\nAnyway!\nRunning Web Assembly (WASM) binary outside of browser context is not unheard of. What if, instead of Python, we could run WASM binaries over a runtime on microcontrollers? That would mean that we can use programming languages like C++, Rust, Go etc. for microcontroller programming! As a bonus, we get the security and flexibility of the WASM sandbox too.\nBuilt by the Bytecode Alliance, the WASM Micro Runtime (aka WAMR) is a step in that direction. In this post, we attempt to run a Rust-generated WASM binary over an ESP32 board using WAMR.\nJust to be clear, this is what we are talking about,\nAll the code samples shared in this post are available as fully working code in this GitHub repo.\nHardware I used an ESP32 development board. Also, I used a RaspberryPi 3B as the compiler and host. There is no particular reason to use RaspberryPi, It‚Äôs just because I had one, and I wanted to use it. Any Windows/Linux/Mac would have been sufficient.\nHere is the entire setup (pretty simple, I would say):\nSoftware Install ExpressIf‚Äôs ESP-IDF toolchain. This is needed to compile anything that could run on an ESP32. Here are the instructions that I followed. Clone wasm-micro-runtime and set its root as $WAMR_PATH. The libc API needed for system calls is provided by wasi-sdk. We need to install this in the environment as $WASI_SDK_PATH so that we can compile the C code to WASM using Clang. However, this is not separately needed for Rust, it ships with rustup‚Äôs wasm32-wasi target. Running C ‚ÄúHello World!‚Äù WAMR already has a sample Hello World! program compiled for WASM. Let us use the same approach and get it running.\nCompile C to WASM Let‚Äôs first take this simple C program, compile it to WASM, and try to run it.\n#include int main(int argc, char **argv) { printf(\"Hello clang world!\\n\"); return 0; } To compile this, we will use the same approach as in the sample provided by WAMR.\nThis will create a test.wasm.\n$ $WASI_SDK_PATH/bin/clang -O3 \\ -z stack-size=4096 -Wl,--initial-memory=65536 \\ -o test.wasm main.c \\ -Wl,--export=main -Wl,--export=__main_argc_argv \\ -Wl,--export=__data_end -Wl,--export=__heap_base \\ -Wl,--strip-all,--no-entry \\ -Wl,--allow-undefined \\ -nostdlib Now, since WAMR do not have file system support over ESP32, we have to convert it into a byte array and include it in the ESP32 build. We can create the binarydump executable that was created in the example project.\n$ binarydump -o test_wasm.h -n wasm_test_file_interp test.wasm This will create a test_wasm.h in array format, which we can include in the ESP build.\nBuild ESP32 binary and flash Now, for this bit, we will copy pretty much everything from the WAMR ESP-IDF sample project from product-mini/platforms/esp-idf folder. Once duplicated, we can simplify a few things.\nThe main/main.c has elaborate support over AOT* as well, which we can remove for the moment. Everything else remains the same. Since this is a large file for a sample code in a blog post, and we are not investigating its content at the moment, I will link to the file from my repo here.\nAlso, the build_and_run.sh can be simplified as,\n#!/bin/bash -e rm -rf build idf.py set-target \"esp32\" idf.py build idf.py flash Now, we need to bring idf.py into the path,\n$ source $IDF_PATH/export.sh And then we run,\n$ ./build_and_run.sh Once this execution is complete (which will take 3 to 4 minutes), if we look at the logs with idf.py monitor command, we can see the Hello World! printed.\n... ... I (344) cpu_start: Starting scheduler on PRO CPU. I (0) cpu_start: Starting scheduler on APP CPU. I (0) wamr: Initialize WASM runtime I (10) wamr: Run wamr with interpreter I (10) wamr: Instantiate WASM runtime I (10) wamr: run main() of the application Hello clang world! I (20) wamr: Deinstantiate WASM runtime I (20) wamr: Unload WASM module I (30) wamr: Destroy WASM runtime I (415) wamr: Exiting... And that brings us to the current state of the art, as given by the WAMR‚Äôs sample esp-idf project.\nRunning Rust ‚ÄúHello World!‚Äù Let‚Äôs start with a simple Hello World! in a main.rs,\nfn main() { println!(\"Hello Rust World!\"); } To compile this to WASM, we need wasm32-wasi target. Let‚Äôs add that,\n$ rustup target add wasm32-wasi And then let‚Äôs compile,\n$ rustc --target wasm32-wasi main.rs Which will generate a main.wasm. Hmm.. Was it that easy? I wish. üòÉ The problem is the size of the wasm binary.\n$ ls -alh main.wasm -rwxr-xr-x@ 1 anoopelias staff 2.0M Jul 27 21:42 main.wasm Just for comparison, the size of the wasm binary generated from C code in the previous section is,\n$ ls -alh test.wasm -rwxr-xr-x@ 1 anoopelias staff 173B Jul 27 21:54 test.wasm A mere 173B for C, while a whopping 2.0M for a Rust WASM binary. Something is off! Something as small as an ESP32 board will not be able to handle a 2MB WASM binary. Believe me, I tried!\nno_std You folks might have guessed by now, the problem is the standard libarary of rust. The entire std library is included in the WASM binary, which causes it to blow up in size. If you carefully noticed, when we compiled the C file, we had a -nostdlib. Can we do the same with Rust?\nBut println! is from std lib! Let‚Äôs get rid of it just for a second.\n#![no_std] fn main() {} $ rustc --target wasm32-wasi main.rs error: `#[panic_handler]` function required, but not found error: aborting due to previous error Usually provided by the stdlib, Rust needs a panic handler available at all times. Typical Rust!\npanic_handler Let‚Äôs add a panic handler, thankfully, the PanicInfo struct is from core lib.\n#![no_std] use core::panic::PanicInfo; #[panic_handler] fn panic(_info: \u0026PanicInfo) -\u003e ! { loop {} } fn main() {} $ rustc --target wasm32-wasi main.rs error: requires `start` lang_item error: aborting due to previous error This error is because, again, std provides the startup bit as well, which also disappeared as a part of no_std.\nno_main, no_mangle Let‚Äôs just do a #![no_main] as well. The WASM runtime will figure out the main function and run it as long as we don‚Äôt allow rustc to mangle with it. So, no_main and no_mangle!\n#![no_std] #![no_main] use core::panic::PanicInfo; #[panic_handler] fn panic(_info: \u0026PanicInfo) -\u003e ! { loop {} } #[no_mangle] fn main() {} $ rustc --target wasm32-wasi main.rs $ ls -alh main.wasm -rwxr-xr-x@ 1 anoopelias staff 425B Jul 28 17:44 main.wasm Great, we have a main.wasm file now that is only 425B.\nLet‚Äôs expand it into wat format to see what is inside. We can use wabt tool for this.\n$ wasm2wat main.wasm (module (type (;0;) (func (result i32))) (type (;1;) (func)) (type (;2;) (func (param i32))) (import \"env\" \"__main_void\" (func $__main_void (type 0))) (import \"env\" \"__wasm_call_dtors\" (func $__wasm_call_dtors (type 1))) (import \"env\" \"__wasi_proc_exit\" (func $__wasi_proc_exit (type 2))) (func $__wasm_call_ctors (type 1)) (func $_start (type 1) (local i32) block ;; label = @1 block ;; label = @2 i32.const 0 i32.load offset=1048576 br_if 0 (;@2;) i32.const 0 i32.const 1 i32.store offset=1048576 call $__wasm_call_ctors call $__main_void local.set 0 call $__wasm_call_dtors local.get 0 br_if 1 (;@1;) return end unreachable unreachable end local.get 0 call $__wasi_proc_exit unreachable) (func $main (type 1) return) (table (;0;) 1 1 funcref) (memory (;0;) 17) (global (;0;) (mut i32) (i32.const 1048576)) (export \"memory\" (memory 0)) (export \"_start\" (func $_start)) (export \"main\" (func $main))) This is still exporting an additional _start function, which is unwanted. We only need to export main to enable WAMR to execute it. It looks like this is coming from wasm32-wasi/lib/self-contained/crt1-command.o added during link time.\nHow do I know? Well, I spent a lot of time looking at how the test.wasm in C is compiled and how it gained the compact size.\nlink-self-contained=no, --no-entry Sending a couple of linker flags should avoid linker to insert the ‚Äúself-contained‚Äù binary. Full command below (no change in main.rs),\n$ rustc -C link-self-contained=no \\ -C link-args=--no-entry \\ --target wasm32-wasi main.rs $ ls -alh main.wasm -rwxr-xr-x@ 1 anoopelias staff 142B Jul 28 22:13 main.wasm $ wasm2wat main.wasm (module (type (;0;) (func)) (func $main (type 0) return) (memory (;0;) 16) (global (;0;) (mut i32) (i32.const 1048576)) (export \"memory\" (memory 0)) (export \"main\" (func $main))) Cool, 142B!. Good enought for now, it‚Äôs ready to be tested. (Remember, we omitted the println!, so expect no output yet.)\nTo run this, like before, we need to convert the main.wasm to an array using binarydump and then run the same build_and_run.sh before,\n$ ./binarydump -o main/test_wasm.h -n wasm_test_file_interp main.wasm $ ./build_and_run.sh And with idf.py monitor, we get an error,\n... ... I (10) wamr: Run wamr with interpreter I (10) wamr: Instantiate WASM runtime E (10) wamr: Error while instantiating: WASM module instantiate failed: allocate memory failed I (20) wamr: Unload WASM module I (30) wamr: Destroy WASM runtime I (414) wamr: Exiting... Why allocate memory failed? Again, I had to dig through a bit, this is somewhat related to the initial value of global stack pointer mentioned in the wat file above. Here is my understanding of the problem,\nThe stack pointer is initialized at the high end of the stack memory. The Rust compiler default stack size is 1MB while, for esp32, we initialized it as 32kB.\n-zstack-size Let us tell the linker that we have only 32kB stack,\n$ rustc -C link-self-contained=no \\ -C link-args=--no-entry \\ -C link-args=-zstack-size=32768 \\ --target wasm32-wasi main.rs $ wasm2wat main.wasm (module (type (;0;) (func)) (func $main (type 0) return) (memory (;0;) 1) (global (;0;) (mut i32) (i32.const 32768)) (export \"memory\" (memory 0)) (export \"main\" (func $main))) Cool, the stack pointer is updated at offset 32768, so let‚Äôs try to run this.\nAgain, same drill as before, and,\n... ... I (0) cpu_start: Starting scheduler on APP CPU. I (0) wamr: Initialize WASM runtime I (10) wamr: Run wamr with interpreter I (10) wamr: Instantiate WASM runtime I (10) wamr: run main() of the application I (20) wamr: Deinstantiate WASM runtime I (20) wamr: Unload WASM module I (30) wamr: Destroy WASM runtime I (414) wamr: Exiting... Phew!, no errors, looks like the file ran successfully.\nWe‚Äôre still missing the Hello World!. Here is the deal: the println! macro is from std lib, which, if we take all of it, then it‚Äôs going to be a huge WASM file. I am not aware of a way to include only the println! and its dependencies, and remove the rest of it.\nputs from C An alternative workaround I borrowed from the C implementation is to call an unsafe C puts function,\n#![no_std] #![no_main] use core::panic::PanicInfo; #[panic_handler] fn panic(_info: \u0026PanicInfo) -\u003e ! { loop {} } extern \"C\" { fn puts(input: *const u8) -\u003e i32; } #[no_mangle] fn main() { let hello = \"Hello Rust World!\"; let hello_ptr: *const u8 = hello.as_ptr() as *const u8; unsafe { puts(hello_ptr); } } Is there a better way to do this? Let me know.\nAnyway, if we compile and run this, we get,\n... ... I (0) cpu_start: Starting scheduler on APP CPU. I (0) wamr: Initialize WASM runtime I (10) wamr: Run wamr with interpreter I (10) wamr: Instantiate WASM runtime I (10) wamr: run main() of the application Hello Rust World! I (20) wamr: Deinstantiate WASM runtime I (20) wamr: Unload WASM module I (30) wamr: Destroy WASM runtime I (415) wamr: Exiting... A well-deserved Hello World!.\nConclusion We were able to run a Rust-compiled WASM over ESP32 using WAMR. While the approach presented here is not a solid solution for running Rust WASM over microcontrollers, wasm-micro-runtime is a promising initiative. With some work and some time, we will be able to look at running Rust and WASM on microcontrollers in production.\nIt has been an incredible learning experience to get this to work. I am looking forward to learning more about Rust, WASM, and microcontrollers.\nThanks for reading. Again, all the code discussed in this post is available in the GitHub repo here.\nPost your comments in Hacker News here.\nCredits: Excalidraw\n* AOT or Ahead-of-Time compilation, is a WASM feature that WAMR can support. This means the *.wasm file will be compiled specific to the target; however, this improves the efficiency of WASM execution by a significant margin. We might explore this idea in a future post.\n","wordCount":"2104","inLanguage":"en","datePublished":"2023-07-30T00:00:00Z","dateModified":"2023-07-30T00:00:00Z","author":{"@type":"Person","name":"Anoop Elias"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://anoopelias.github.io/posts/wasm-micro-runtime-with-rust/"},"publisher":{"@type":"Organization","name":"Anoop's page","logo":{"@type":"ImageObject","url":"https://anoopelias.github.io/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://anoopelias.github.io accesskey=h title="Anoop's page (Alt + H)">Anoop's page</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://anoopelias.github.io/side-projects/side-projects title="My side projects"><span>My side projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>WASM Micro Runtime with Rust</h1><div class=post-meta><span title='2023-07-30 00:00:00 +0000 UTC'>July 30, 2023</span>&nbsp;¬∑&nbsp;10 min&nbsp;¬∑&nbsp;Anoop Elias</div></header><div class=post-content><p>Traditionally, microcontrollers are known to be able to run only C code. Firmware developers will usually have an Eclipse-based IDE as well as a custom compiler toolchain to compile the code against the target. This has been changing a lot. For example, <a href=https://micropython.org/>MicroPython</a> has become popular recently. RaspberryPi Pico, ExpressIf&rsquo;s ESP32 are some microcontrollers that have fairly good support for MicroPython. See antirez&rsquo;s <a href=https://github.com/antirez/talk32>talk32</a> project, which attempts to improve the MicroPython tooling and developer workflow for ESP32.</p><p>Anyway!</p><p>Running <a href=https://webassembly.org/>Web Assembly</a> (WASM) binary <em>outside</em> of browser context <a href=https://github.com/bytecodealliance/wasmtime>is not unheard of</a>. What if, instead of Python, we could run WASM binaries over a runtime on microcontrollers? That would mean that we can use programming languages like C++, Rust, Go etc. for microcontroller programming! As a bonus, we get the security and flexibility of the WASM sandbox too.</p><p>Built by the Bytecode Alliance, the <a href=https://github.com/bytecodealliance/wasm-micro-runtime>WASM Micro Runtime</a> (aka WAMR) is a step in that direction. In this post, we attempt to run a Rust-generated WASM binary over an ESP32 board using WAMR.</p><p>Just to be clear, this is what we are talking about,</p><p><img loading=lazy src=/posts/esp32-architecture.png alt></p><p>All the code samples shared in this post are available as fully working code in <a href=https://github.com/anoopelias/hello-wasm-esp32>this</a> GitHub repo.</p><h2 id=hardware>Hardware<a hidden class=anchor aria-hidden=true href=#hardware>#</a></h2><p>I used an <a href=https://robocraze.com/products/nodemcu-32-wifi-bluetooth-esp32-development-board30-pin>ESP32 development board</a>. Also, I used a RaspberryPi 3B as the compiler and host. There is no particular reason to use RaspberryPi, It&rsquo;s just because I had one, and I wanted to use it. Any Windows/Linux/Mac would have been sufficient.</p><p>Here is the entire setup (pretty simple, I would say):</p><p><img loading=lazy src=/posts/esp32-pi.jpg alt></p><h2 id=software>Software<a hidden class=anchor aria-hidden=true href=#software>#</a></h2><ul><li>Install ExpressIf&rsquo;s ESP-IDF toolchain. This is needed to compile anything that could run on an ESP32. <a href=https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/linux-macos-setup.html>Here</a> are the instructions that I followed.</li><li>Clone <a href=https://github.com/bytecodealliance/wasm-micro-runtime><code>wasm-micro-runtime</code></a> and set its root as <code>$WAMR_PATH</code>.</li><li>The libc API needed for system calls is provided by <a href=https://github.com/WebAssembly/wasi-sdk><code>wasi-sdk</code></a>. We need to install this in the environment as <code>$WASI_SDK_PATH</code> so that we can compile the C code to WASM using Clang. However, this is not separately needed for Rust, it ships with rustup&rsquo;s <code>wasm32-wasi</code> target.</li></ul><h2 id=running-c-hello-world>Running C &ldquo;Hello World!&rdquo;<a hidden class=anchor aria-hidden=true href=#running-c-hello-world>#</a></h2><p>WAMR already has a <a href=https://github.com/bytecodealliance/wasm-micro-runtime/tree/17f62ad472b04add0e5c53fd99a3746b7b3ea131/product-mini/app-samples/hello-world>sample Hello World! program</a> compiled for WASM. Let us use the same approach and get it running.</p><h3 id=compile-c-to-wasm>Compile C to WASM<a hidden class=anchor aria-hidden=true href=#compile-c-to-wasm>#</a></h3><p>Let&rsquo;s first take this simple C program, compile it to WASM, and try to run it.</p><pre tabindex=0><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
    printf(&#34;Hello clang world!\n&#34;);
    return 0;
}
</code></pre><p>To compile this, we will use the <a href=https://github.com/bytecodealliance/wasm-micro-runtime/blob/6110ea39fdcb9e86683213b6036c2787c0b9e9a5/product-mini/app-samples/hello-world/build.sh#L7>same approach</a> as in the sample provided by WAMR.</p><p>This will create a <code>test.wasm</code>.</p><pre tabindex=0><code>$ $WASI_SDK_PATH/bin/clang -O3 \
        -z stack-size=4096 -Wl,--initial-memory=65536 \
        -o test.wasm main.c \
        -Wl,--export=main -Wl,--export=__main_argc_argv \
        -Wl,--export=__data_end -Wl,--export=__heap_base \
        -Wl,--strip-all,--no-entry \
        -Wl,--allow-undefined \
        -nostdlib
</code></pre><p>Now, since WAMR do not have file system support over ESP32, we have to convert it into a byte array and include it in the ESP32 build. We can create the <code>binarydump</code> executable that was created in the example project.</p><pre tabindex=0><code>$ binarydump -o test_wasm.h -n wasm_test_file_interp test.wasm
</code></pre><p>This will create a <code>test_wasm.h</code> in array format, which we can include in the ESP build.</p><h3 id=build-esp32-binary-and-flash>Build ESP32 binary and flash<a hidden class=anchor aria-hidden=true href=#build-esp32-binary-and-flash>#</a></h3><p>Now, for this bit, we will copy pretty much everything from the WAMR ESP-IDF sample project from <a href=https://github.com/bytecodealliance/wasm-micro-runtime/tree/ada7e3fe881473818789c9a5d4c38e7ff0bf4054/product-mini/platforms/esp-idf><code>product-mini/platforms/esp-idf</code></a> folder. Once duplicated, we can simplify a few things.</p><p>The <code>main/main.c</code> has elaborate support over AOT* as well, which we can remove for the moment. Everything else remains the same. Since this is a large file for a sample code in a blog post, and we are not investigating its content at the moment, I will link to the file from my repo <a href=https://github.com/anoopelias/hello-wasm-esp32/blob/a4ced6be7a668fd432f9373f7180fe64163b2e37/main/main.c>here</a>.</p><p>Also, the <code>build_and_run.sh</code> can be simplified as,</p><pre tabindex=0><code>#!/bin/bash -e
rm -rf build
idf.py set-target &#34;esp32&#34;
idf.py build
idf.py flash
</code></pre><p>Now, we need to bring <code>idf.py</code> into the path,</p><pre tabindex=0><code>$ source $IDF_PATH/export.sh
</code></pre><p>And then we run,</p><pre tabindex=0><code>$ ./build_and_run.sh
</code></pre><p>Once this execution is complete (which will take 3 to 4 minutes), if we look at the logs with <code>idf.py monitor</code> command, we can see the <code>Hello World!</code> printed.</p><pre tabindex=0><code>...
...
I (344) cpu_start: Starting scheduler on PRO CPU.
I (0) cpu_start: Starting scheduler on APP CPU.
I (0) wamr: Initialize WASM runtime
I (10) wamr: Run wamr with interpreter
I (10) wamr: Instantiate WASM runtime
I (10) wamr: run main() of the application
Hello clang world!
I (20) wamr: Deinstantiate WASM runtime
I (20) wamr: Unload WASM module
I (30) wamr: Destroy WASM runtime
I (415) wamr: Exiting...
</code></pre><p>And that brings us to the current state of the art, as given by the WAMR&rsquo;s sample esp-idf project.</p><h2 id=running-rust-hello-world>Running Rust &ldquo;Hello World!&rdquo;<a hidden class=anchor aria-hidden=true href=#running-rust-hello-world>#</a></h2><p>Let&rsquo;s start with a simple <code>Hello World!</code> in a <code>main.rs</code>,</p><pre tabindex=0><code>fn main() {
    println!(&#34;Hello Rust World!&#34;);
}
</code></pre><p>To compile this to WASM, we need <code>wasm32-wasi</code> target. Let&rsquo;s add that,</p><pre tabindex=0><code>$ rustup target add wasm32-wasi
</code></pre><p>And then let&rsquo;s compile,</p><pre tabindex=0><code>$ rustc --target wasm32-wasi main.rs
</code></pre><p>Which will generate a <code>main.wasm</code>. Hmm.. Was it that easy? I wish. üòÉ The problem is the size of the wasm binary.</p><pre tabindex=0><code>$ ls -alh main.wasm
-rwxr-xr-x@ 1 anoopelias  staff   2.0M Jul 27 21:42 main.wasm
</code></pre><p>Just for comparison, the size of the wasm binary generated from C code in the previous section is,</p><pre tabindex=0><code>$ ls -alh test.wasm
-rwxr-xr-x@ 1 anoopelias  staff   173B Jul 27 21:54 test.wasm
</code></pre><p>A mere <code>173B</code> for C, while a whopping <code>2.0M</code> for a Rust WASM binary. Something is off! Something as small as an ESP32 board will not be able to handle a 2MB WASM binary. Believe me, I tried!</p><h3 id=no_std><code>no_std</code><a hidden class=anchor aria-hidden=true href=#no_std>#</a></h3><p>You folks might have guessed by now, the problem is the <em>standard libarary of rust</em>. The entire <code>std</code> library is included in the WASM binary, which causes it to blow up in size. If you carefully noticed, when we compiled the C file, we had a <code>-nostdlib</code>. Can we do the same with Rust?</p><p>But <code>println!</code> is from <code>std</code> lib! Let&rsquo;s get rid of it just for a second.</p><pre tabindex=0><code>#![no_std]

fn main() {}
</code></pre><pre tabindex=0><code>$ rustc --target wasm32-wasi main.rs
error: `#[panic_handler]` function required, but not found

error: aborting due to previous error
</code></pre><p>Usually provided by the stdlib, Rust needs a panic handler available at all times. Typical Rust!</p><h3 id=panic_handler><code>panic_handler</code><a hidden class=anchor aria-hidden=true href=#panic_handler>#</a></h3><p>Let&rsquo;s add a panic handler, thankfully, the <code>PanicInfo</code> struct is from <code>core</code> lib.</p><pre tabindex=0><code>#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}

fn main() {}
</code></pre><pre tabindex=0><code>$ rustc --target wasm32-wasi main.rs
error: requires `start` lang_item

error: aborting due to previous error
</code></pre><p>This error is because, again, <code>std</code> provides the startup bit as well, which also disappeared as a part of <code>no_std</code>.</p><h3 id=no_main-no_mangle><code>no_main</code>, <code>no_mangle</code><a hidden class=anchor aria-hidden=true href=#no_main-no_mangle>#</a></h3><p>Let&rsquo;s just do a <code>#![no_main]</code> as well. The WASM runtime will figure out the main function and run it as long as we don&rsquo;t allow <code>rustc</code> to mangle with it. So, <code>no_main</code> and <code>no_mangle</code>!</p><pre tabindex=0><code>#![no_std]
#![no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}

#[no_mangle]
fn main() {}
</code></pre><pre tabindex=0><code>$ rustc --target wasm32-wasi main.rs
$ ls -alh main.wasm
-rwxr-xr-x@ 1 anoopelias  staff   425B Jul 28 17:44 main.wasm
</code></pre><p>Great, we have a <code>main.wasm</code> file now that is only <code>425B</code>.</p><p>Let&rsquo;s expand it into <a href=https://webassembly.github.io/spec/core/text/index.html>wat format</a> to see what is inside. We can use <a href=https://github.com/WebAssembly/wabt>wabt</a> tool for this.</p><pre tabindex=0><code>$ wasm2wat main.wasm
(module
  (type (;0;) (func (result i32)))
  (type (;1;) (func))
  (type (;2;) (func (param i32)))
  (import &#34;env&#34; &#34;__main_void&#34; (func $__main_void (type 0)))
  (import &#34;env&#34; &#34;__wasm_call_dtors&#34; (func $__wasm_call_dtors (type 1)))
  (import &#34;env&#34; &#34;__wasi_proc_exit&#34; (func $__wasi_proc_exit (type 2)))
  (func $__wasm_call_ctors (type 1))
  (func $_start (type 1)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        i32.const 0
        i32.load offset=1048576
        br_if 0 (;@2;)
        i32.const 0
        i32.const 1
        i32.store offset=1048576
        call $__wasm_call_ctors
        call $__main_void
        local.set 0
        call $__wasm_call_dtors
        local.get 0
        br_if 1 (;@1;)
        return
      end
      unreachable
      unreachable
    end
    local.get 0
    call $__wasi_proc_exit
    unreachable)
  (func $main (type 1)
    return)
  (table (;0;) 1 1 funcref)
  (memory (;0;) 17)
  (global (;0;) (mut i32) (i32.const 1048576))
  (export &#34;memory&#34; (memory 0))
  (export &#34;_start&#34; (func $_start))
  (export &#34;main&#34; (func $main)))
</code></pre><p>This is still exporting an additional <code>_start</code> function, which is unwanted. We only need to export <code>main</code> to enable WAMR to execute it. It looks like this is coming from <code>wasm32-wasi/lib/self-contained/crt1-command.o</code> added during link time.</p><p>How do I know? Well, I spent a lot of time looking at how the <code>test.wasm</code> in C is compiled and how it gained the compact size.</p><h3 id=link-self-containedno---no-entry><code>link-self-contained=no</code>, <code>--no-entry</code><a hidden class=anchor aria-hidden=true href=#link-self-containedno---no-entry>#</a></h3><p>Sending a couple of linker flags should avoid linker to insert the &ldquo;self-contained&rdquo; binary. Full command below (no change in <code>main.rs</code>),</p><pre tabindex=0><code>$ rustc -C link-self-contained=no \
    -C link-args=--no-entry \
    --target wasm32-wasi main.rs
$ ls -alh main.wasm
-rwxr-xr-x@ 1 anoopelias  staff   142B Jul 28 22:13 main.wasm
$ wasm2wat main.wasm
(module
  (type (;0;) (func))
  (func $main (type 0)
    return)
  (memory (;0;) 16)
  (global (;0;) (mut i32) (i32.const 1048576))
  (export &#34;memory&#34; (memory 0))
  (export &#34;main&#34; (func $main)))
</code></pre><p>Cool, <code>142B</code>!. Good enought for now, it&rsquo;s ready to be tested. (Remember, we omitted the <code>println!</code>, so expect no output yet.)</p><p>To run this, like before, we need to convert the <code>main.wasm</code> to an array using <code>binarydump</code> and then run the same <code>build_and_run.sh</code> before,</p><pre tabindex=0><code>$ ./binarydump -o main/test_wasm.h -n wasm_test_file_interp main.wasm
$ ./build_and_run.sh
</code></pre><p>And with <code>idf.py monitor</code>, we get an error,</p><pre tabindex=0><code>...
...
I (10) wamr: Run wamr with interpreter
I (10) wamr: Instantiate WASM runtime
E (10) wamr: Error while instantiating: WASM module instantiate failed: allocate memory failed
I (20) wamr: Unload WASM module
I (30) wamr: Destroy WASM runtime
I (414) wamr: Exiting...
</code></pre><p>Why <code>allocate memory failed</code>? Again, I had to dig through a bit, this is somewhat related to the initial value of <code>global</code> stack pointer mentioned in the wat file above. Here is my understanding of the problem,</p><p><img loading=lazy src=/posts/esp32-memory-model.png alt></p><p>The stack pointer is initialized at the high end of the stack memory. The <a href=https://github.com/rust-lang/rust/blob/2e0136a131f6ed5f6071adf36db08dd8d2205d19/compiler/rustc_target/src/spec/wasm_base.rs#L12>Rust compiler default stack size</a> is <code>1MB</code> while, for esp32, <a href=https://github.com/anoopelias/hello-wasm-esp32/blob/ff8e5d961194a55309d4de87a9bd42bc5b6f27a6/main/main.c#L67>we initialized it</a> as <code>32kB</code>.</p><h3 id=-zstack-size><code>-zstack-size</code><a hidden class=anchor aria-hidden=true href=#-zstack-size>#</a></h3><p>Let us tell the linker that we have only <code>32kB</code> stack,</p><pre tabindex=0><code>$ rustc -C link-self-contained=no \
    -C link-args=--no-entry \
    -C link-args=-zstack-size=32768 \
    --target wasm32-wasi main.rs
$ wasm2wat main.wasm
(module
  (type (;0;) (func))
  (func $main (type 0)
    return)
  (memory (;0;) 1)
  (global (;0;) (mut i32) (i32.const 32768))
  (export &#34;memory&#34; (memory 0))
  (export &#34;main&#34; (func $main)))
</code></pre><p>Cool, the stack pointer is updated at offset <code>32768</code>, so let&rsquo;s try to run this.</p><p>Again, same drill as before, and,</p><pre tabindex=0><code>...
...
I (0) cpu_start: Starting scheduler on APP CPU.
I (0) wamr: Initialize WASM runtime
I (10) wamr: Run wamr with interpreter
I (10) wamr: Instantiate WASM runtime
I (10) wamr: run main() of the application
I (20) wamr: Deinstantiate WASM runtime
I (20) wamr: Unload WASM module
I (30) wamr: Destroy WASM runtime
I (414) wamr: Exiting...
</code></pre><p>Phew!, no errors, looks like the file ran successfully.</p><p>We&rsquo;re still missing the <code>Hello World!</code>. Here is the deal: the <code>println!</code> macro is from <code>std</code> lib, which, if we take all of it, then it&rsquo;s going to be a huge WASM file. I am <em>not</em> aware of a way to include <em>only</em> the <code>println!</code> and its dependencies, and remove the rest of it.</p><h3 id=puts-from-c><code>puts</code> from C<a hidden class=anchor aria-hidden=true href=#puts-from-c>#</a></h3><p>An alternative workaround I borrowed from the C implementation is to call an <code>unsafe</code> C <code>puts</code> function,</p><pre tabindex=0><code>#![no_std]
#![no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}

extern &#34;C&#34; {
    fn puts(input: *const u8) -&gt; i32;
}

#[no_mangle]
fn main() {
    let hello = &#34;Hello Rust World!&#34;;
    let hello_ptr: *const u8 = hello.as_ptr() as *const u8;

    unsafe {
        puts(hello_ptr);
    }
}
</code></pre><p>Is there a better way to do this? Let me know.</p><p>Anyway, if we compile and run this, we get,</p><pre tabindex=0><code>...
...
I (0) cpu_start: Starting scheduler on APP CPU.
I (0) wamr: Initialize WASM runtime
I (10) wamr: Run wamr with interpreter
I (10) wamr: Instantiate WASM runtime
I (10) wamr: run main() of the application
Hello Rust World!
I (20) wamr: Deinstantiate WASM runtime
I (20) wamr: Unload WASM module
I (30) wamr: Destroy WASM runtime
I (415) wamr: Exiting...
</code></pre><p>A well-deserved <code>Hello World!</code>.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>We were able to run a Rust-compiled WASM over ESP32 using WAMR. While the approach presented here is not a <em>solid</em> solution for running Rust WASM over microcontrollers, <a href=https://github.com/bytecodealliance/wasm-micro-runtime><code>wasm-micro-runtime</code></a> is a promising initiative. With some work and some time, we will be able to look at running Rust and WASM on microcontrollers in production.</p><p>It has been an incredible learning experience to get this to work. I am looking forward to learning more about Rust, WASM, and microcontrollers.</p><p>Thanks for reading. Again, all the code discussed in this post is available in the GitHub repo <a href=https://github.com/anoopelias/hello-wasm-esp32>here</a>.</p><p>Post your comments in Hacker News <a href="https://news.ycombinator.com/item?id=36944054">here</a>.</p><hr><p><strong>Credits</strong>: <a href=https://excalidraw.com/>Excalidraw</a></p><p>* AOT or Ahead-of-Time compilation, is a WASM feature that WAMR can support. This means the <code>*.wasm</code> file will be compiled specific to the target; however, this improves the efficiency of WASM execution by a significant margin. We might explore this idea in a future post.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://anoopelias.github.io>Anoop's page</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>